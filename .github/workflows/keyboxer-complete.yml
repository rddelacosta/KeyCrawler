name: Run KeyBoxer (Store in Private Gist)

on:
  schedule:
    - cron: '0 0 * * *'  # Run daily at midnight UTC
  workflow_dispatch:  # Allow manual triggering

jobs:
  run-keyboxer:
    runs-on: ubuntu-latest
    timeout-minutes: 30  # Set a timeout for the entire job
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
      
      - name: Install dependencies
        run: |
          pip install requests python-dotenv beautifulsoup4 lxml cryptography
      
      - name: Create required directories
        run: |
          mkdir -p keys
          touch cache.txt
      
      - name: Create .env file with GitHub token
        run: |
          echo "GITHUB_TOKEN=${{ secrets.PAT_TOKEN }}" > .env
      
      - name: Create patched version of check.py
        run: |
          # Create a backup of the original file
          cp check.py check.py.original
          
          # Create a patched version that fixes the XML encoding issue
          cat > check.py << 'EOL'
          # Import the original functionality from the backup
          from check_original import *
          
          # Override the keybox_check function to handle the encoding issue
          def keybox_check(xml_content):
              try:
                  # If the content is a string, convert it to bytes
                  if isinstance(xml_content, str):
                      # Remove XML declaration if present to avoid the encoding error
                      if "<?xml" in xml_content and "encoding=" in xml_content:
                          xml_content = xml_content.split("?>", 1)[-1].strip()
                      
                      # Call the original function with the modified content
                      return original_keybox_check(xml_content)
                  else:
                      # If it's already bytes, use it as is
                      return original_keybox_check(xml_content)
              except Exception as e:
                  print(f"[Fixed Keybox Check Error]: {str(e)}")
                  # Return False for invalid XML but allow the process to continue
                  return False
          EOL
          
          # Rename the original file to be imported by the patch
          mv check.py.original check_original.py
          
          # Modify the import in the original file to expose the original function
          sed -i 's/def keybox_check/def original_keybox_check/g' check_original.py
      
      - name: Create non-interactive script with fixes
        run: |
          cat > run_fixed.py << 'EOL'
          import os
          import sys
          import time
          import signal
          import subprocess
          
          # Set a timeout of 10 minutes for the script execution
          TIMEOUT = 600  # 10 minutes in seconds
          
          # Define timeout handler
          def timeout_handler(signum, frame):
              print("Script execution timed out after 10 minutes.")
              sys.exit(0)  # Exit gracefully
          
          # Register the timeout handler
          signal.signal(signal.SIGALRM, timeout_handler)
          signal.alarm(TIMEOUT)
          
          # Create a process for the keyboxer script
          process = subprocess.Popen(
              ['python', './keyboxer.py'],
              stdin=subprocess.PIPE,
              stdout=subprocess.PIPE,
              stderr=subprocess.STDOUT,
              text=True,
              bufsize=1
          )
          
          # Process output and handle prompts
          while True:
              line = process.stdout.readline()
              if not line and process.poll() is not None:
                  break
                  
              print(line, end='', flush=True)
              
              # Auto-respond to deletion prompts
              if "Do you want to delete it? (y/N)" in line:
                  print("Auto-responding: y")
                  process.stdin.write("y\n")
                  process.stdin.flush()
          
          # Cancel the alarm if we exit normally
          signal.alarm(0)
          
          print("\nScript execution completed.")
          print("Listing collected files:")
          os.system("ls -la keys/")
          
          # Exit with success
          sys.exit(0)
          EOL
        
      - name: Run fixed script
        run: |
          python run_fixed.py
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
          
      - name: List results
        run: |
          echo "KeyBoxer execution complete"
          echo "Contents of keys directory:"
          ls -la keys/ || echo "No files found in keys directory"
      
      - name: Compress keys directory
        run: |
          zip -r keybox-files.zip keys/
          echo "Created zip archive of keys directory"
          ls -la keybox-files.zip
      
      - name: Create or update private Gist with results
        run: |
          # Get current date for the gist description
          DATE=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          # Create a JSON payload for the GitHub API
          cat > gist-payload.json << EOF
          {
            "description": "KeyBoxer collected files - $DATE",
            "public": false,
            "files": {
              "keybox-files.txt": {
                "content": "KeyBoxer run completed on $DATE\n\nList of files collected:\n$(ls -la keys/)"
              }
            }
          }
          EOF
          
          # Check if we have an existing Gist ID stored
          GIST_ID_FILE=".gist-id"
          GIST_ID=""
          if [ -f "$GIST_ID_FILE" ]; then
            GIST_ID=$(cat "$GIST_ID_FILE")
            echo "Found existing Gist ID: $GIST_ID"
            
            # Update existing Gist
            RESPONSE=$(curl -s -X PATCH \
              -H "Authorization: token ${{ secrets.GIST_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              -d @gist-payload.json \
              "https://api.github.com/gists/$GIST_ID")
              
            echo "Updated existing Gist"
          else
            # Create new Gist
            RESPONSE=$(curl -s -X POST \
              -H "Authorization: token ${{ secrets.GIST_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              -d @gist-payload.json \
              "https://api.github.com/gists")
              
            # Extract and save Gist ID for future updates
            GIST_ID=$(echo "$RESPONSE" | grep -o '"id": "[^"]*' | head -1 | cut -d'"' -f4)
            echo "$GIST_ID" > "$GIST_ID_FILE"
            echo "Created new Gist with ID: $GIST_ID"
          fi
          
          # Now upload the actual zip file to the Gist
          # First, base64 encode the zip file
          BASE64_ZIP=$(base64 -w 0 keybox-files.zip)
          
          # Create a JSON payload for updating the Gist with the zip file
          cat > gist-update-payload.json << EOF
          {
            "files": {
              "keybox-files.zip.base64": {
                "content": "$BASE64_ZIP"
              }
            }
          }
          EOF
          
          # Update the Gist with the encoded zip file
          curl -s -X PATCH \
            -H "Authorization: token ${{ secrets.GIST_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            -d @gist-update-payload.json \
            "https://api.github.com/gists/$GIST_ID"
            
          echo "Uploaded base64-encoded zip file to Gist"
          echo "You can find your files at: https://gist.github.com/$GIST_ID"
          echo "This Gist is private and only visible to you"
